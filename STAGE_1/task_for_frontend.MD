# ğŸ§  Etapa 1: Dominando la asincronÃ­a en Frontend como un Senior

**Objetivo general:**
Adquirir criterio tÃ©cnico real para enfrentar escenarios asincrÃ³nicos en aplicaciones web, entendiendo mÃ©todos de carga, streams en el navegador, control de concurrencia y experiencia de usuario durante operaciones complejas.

**Al completar esta etapa, podrÃ¡s:**
- Construir interfaces responsivas que no se bloquean en operaciones largas.
- Implementar feedback visual (spinners, barras de progreso, placeholders).
- Manejar peticiones paralelas, lazy loading y cancelaciones.
- Controlar concurrencia, gestionar rate limiting y backpressure con Fetch API.
- Ofrecer UX robusta ante errores, timeouts y cambios en la conectividad.

ğŸ“Œ *Esta etapa estÃ¡ pensada para ejercitar la cabeza, no solo los dedos.*

---

## ğŸ“‚ Ejercicioâ€¯1: Carga de un recurso con feedback visual

### ğŸ¯ Objetivo
Crear una interfaz sencilla que descargue un recurso pesado y muestre al usuario el estado de la operaciÃ³n.

### âœï¸ Instrucciones
1. Crea una pÃ¡gina HTML + CSS + JavaScript (vanilla o framework ligero).
2. AÃ±ade un botÃ³n â€œCargar recursoâ€. Al hacer clic:
    - Inicia `fetch(url)` a `https://picsum.photos/3000/2000` (imagen) o `https://jsonplaceholder.typicode.com/photos` (JSON).
    - Usa `AbortController` para timeout a 10â€¯s.
    - Mientras descarga, muestra un spinner o mensaje â€œCargandoâ€¦â€.
3. Cuando termine:
    - Si es imagen, muestra la imagen en la pÃ¡gina.
    - Si es JSON, muestra el nÃºmero de objetos recibidos.
4. Muestra mensajes de error segÃºn el cÃ³digo HTTP o timeout.

### ğŸ” Puntos a cubrir
- ImplementaciÃ³n de timeout con `AbortController`.
- No bloquear el hilo principal.
- UX de error: diferenciar 401, 404, 500 y timeout.

### â“ ReflexiÃ³n
> Â¿QuÃ© diferencias observaste entre `XMLHttpRequest` y `fetch` al manejar estados de carga?

---

## ğŸ“‚ Ejercicioâ€¯2: GalerÃ­a paralela con placeholders

### ğŸ¯ Objetivo
Construir una galerÃ­a que cargue mÃºltiples imÃ¡genes en paralelo mostrando su progreso individual.

### âœï¸ Instrucciones
1. Crea un grid que acepte 20 URLs de imÃ¡genes (pueden ser de `picsum.photos`).
2. Para cada URL:
    - Renderiza un placeholder (cuadro gris).
    - Lanza la descarga con `fetch` y `.blob()`.
    - Al finalizar, crea un object URL y asigna `src` a un `<img>`.
    - Si falla, muestra un Ã­cono de error.
3. Muestra un contador global (â€œ5/20 cargadasâ€) y el tiempo total.
4. Permite al usuario cancelar una descarga especÃ­fica con `AbortController`.

### ğŸ” Puntos a cubrir
- ActualizaciÃ³n eficiente del DOM.
- Control de cancelaciÃ³n y liberaciÃ³n de recursos (`URL.revokeObjectURL`).

### â“ ReflexiÃ³n
> Â¿CuÃ¡ndo conviene usar `Promise.all` vs. descargas individuales con `Promise.race`?

---

## ğŸ“‚ Ejercicioâ€¯2.5: Lazy loading y optimizaciÃ³n de scroll

### ğŸ¯ Objetivo
Implementar carga perezosa de imÃ¡genes segÃºn su visibilidad en pantalla.

### âœï¸ Instrucciones
1. A partir de la galerÃ­a anterior, usa `IntersectionObserver` para detectar elementos cerca del viewport.
2. Solo al detectarlos, inicia `fetch` y reemplaza el placeholder.
3. Implementa carga progresiva: baja resoluciÃ³n primero y luego alta.
4. Cancela peticiones si el usuario hace scroll rÃ¡pido y el elemento sale del viewport.

### ğŸ” Puntos a cubrir
- Impacto en el tiempo de carga inicial.
- Mecanismo de cancelaciÃ³n con `AbortController`.

### â“ ReflexiÃ³n
> Â¿CÃ³mo afectarÃ­a esta tÃ©cnica a un feed infinito (infinite scroll)?

---

## ğŸ“‚ Ejercicioâ€¯3: Autocompletado con debounce y throttling

### ğŸ¯ Objetivo
Crear un campo de bÃºsqueda que consulte una API y ofrezca sugerencias en tiempo real, respetando lÃ­mites de peticiones.

### âœï¸ Instrucciones
1. Usa una API pÃºblica (p.ej. OpenLibrary Search).
2. Al escribir en un input:
    - Aplica debounce de 300â€¯ms (p.ej. con `lodash.debounce`).
    - Cancela la peticiÃ³n anterior al iniciar una nueva.
    - Limita a 3 peticiones concurrentes; en exceso, encola las solicitudes.
3. Muestra debajo del input una lista de sugerencias.
4. Implementa cachÃ© en memoria para consultas repetidas.

### ğŸ” Puntos a cubrir
- Debounce vs. throttle: cuÃ¡ndo usar cada uno.
- GestiÃ³n de colas simples en frontend.

### â“ ReflexiÃ³n
> Â¿CÃ³mo mejorarÃ­as la UX si la API aplica rate limiting (429)?

---

## ğŸš€ Ejercicioâ€¯4: SPA con gestiÃ³n avanzada de estados

### ğŸ¯ Objetivo
Desarrollar una mini-aplicaciÃ³n que unifique lo aprendido: descargas, concurrencia, cachÃ© y UX de errores.

### âœï¸ Instrucciones
1. Elige un framework ligero (Vue, React o vanilla modular) y crea una SPA de â€œBiblioteca de pelÃ­culasâ€:
    - Listado paginado desde TMDB u OMDB.
    - BÃºsqueda en tiempo real con autocompletado.
    - Vista de detalle que carga datos adicionales bajo demanda.
2. Implementa:
    - CachÃ© con TTL.
    - Precarga inteligente (prefetch) de rutas o datos.
    - Estados visuales: loading, error, empty, success.
    - Reintentos automÃ¡ticos con backoff exponencial.
3. AÃ±ade opciÃ³n de exportar resultados a CSV o JSON.

### ğŸ” Puntos a cubrir
- Arquitectura de manejo centralizado de peticiones (servicio/API client).
- Uso de Web Workers si la UI sufre bloqueos.
- Estrategias offline: Service Worker o cachÃ© local.

### â“ ReflexiÃ³n
> Â¿CÃ³mo diseÃ±arÃ­as un mecanismo de resumir descargas si la sesiÃ³n del usuario se interrumpe?

---

## ğŸ“š Recursos Ãºtiles
- [Fetch API](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)
- [AbortController](https://developer.mozilla.org/en-US/docs/Web/API/AbortController)
- [IntersectionObserver](https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API)
- [Lodash Debounce/Throttle](https://lodash.com/docs/#debounce)
- [Service Workers](https://developer.mozilla.org/en-US/docs/Web/API/Service_Worker_API)
- [Performance API](https://developer.mozilla.org/en-US/docs/Web/API/Performance_API)

