# ğŸ§  Etapa 1: Dominando la asincronÃ­a y gestiÃ³n de descargas en Frontend como un Senior

**Objetivo general:**
Construir aplicaciones web que descargan y gestionan archivos en el navegador, manejando asincronÃ­a, streams, concurrencia y UI de progreso de forma escalable y mantenible.

**Al completar esta etapa, podrÃ¡s:**
- Elegir entre buffer vs. stream en el navegador.
- Controlar concurrencia y backpressure en fetch.
- Mostrar barras de progreso e indicadores de estado en la UI.
- Manejar errores (red, disco virtual, lÃ­mites de API) y reintentos.

---

## ğŸ“‚ Ejercicioâ€¯1: Descarga bÃ¡sica con Fetch y Blob

### ğŸ¯ Objetivo
Descargar un Ãºnico archivo desde una URL concreta y ofrecerlo para guardar en el navegador, con UI mÃ­nima de progreso.

### âœï¸ Instrucciones
1. Crea una pÃ¡gina web o componente (p.ej. React/Vue) con un input de URL y un botÃ³n â€œDescargarâ€.
2. Al hacer clic, usa `fetch(url)` para:
    - Seguir redirecciones (comportamiento por defecto).
    - Soportar **Basic Auth** enviando cabeceras `Authorization` si hay credenciales.
3. Llama a `response.blob()` y crea un enlace `<a download>` con `URL.createObjectURL(blob)` para iniciar la descarga.
4. En la UI, muestra un spinner o mensaje â€œDescargandoâ€¦â€ hasta completar.

### ğŸ” Puntos a cubrir
- Â¿CÃ³mo indicas al usuario un **401** o un error de red?
- Â¿QuÃ© UX ofreces si la descarga tarda mucho?

### â“ ReflexiÃ³n
> Â¿Por quÃ© elegiste Blob vs. streams directos para esta primera implementaciÃ³n?

---

## ğŸ“‚ Ejercicioâ€¯2: Descarga paralela con indicadores por archivo

### ğŸ¯ Objetivo
Extender la UI para gestionar mÃºltiples descargas simultÃ¡neas, cada una con su propio estado y progreso.

### âœï¸ Instrucciones
1. Permite al usuario introducir una lista de **al menos 5 URLs** (textarea o inputs dinÃ¡micos).
2. Al iniciar, lanza todas las descargas con `Promise.allSettled`.
3. Por cada archivo, muestra en una lista: nombre (URL), estado (descargando, Ã©xito, error) y tiempo transcurrido.
4. Si falla alguno, muestra el error y deja los demÃ¡s descargando.

### ğŸ” Puntos a cubrir
- Â¿CÃ³mo actualizas el estado en el DOM de forma eficiente?
- Â¿CÃ³mo cancelas una descarga en curso (AbortController)?

### â“ ReflexiÃ³n
> Â¿QuÃ© ventajas te da manejar estados por archivo en lugar de un mensaje global?

---

## ğŸ“‚ Ejercicioâ€¯2.5: Streams y progreso en tiempo real

### ğŸ¯ Objetivo
Usar la API de streams de Fetch para mostrar progreso real de la descarga.

### âœï¸ Instrucciones
1. Reemplaza `response.blob()` por un lector de stream:
   ```js
   const reader = response.body.getReader();
   const contentLength = +response.headers.get('Content-Length');
   let received = 0;
   const chunks = [];
   while(true) {
     const { done, value } = await reader.read();
     if (done) break;
     chunks.push(value);
     received += value.length;
     updateProgress(received / contentLength);
   }
   const blob = new Blob(chunks);
   ```  
2. En la interfaz, dibuja una barra de progreso que refleje `updateProgress()`.

### ğŸ” Puntos a cubrir
- Â¿CÃ³mo reaccionas si `Content-Length` es `null`?
- Â¿QuÃ© sucede si la escritura de chunks es mÃ¡s lenta que la llegada de datos?

### â“ ReflexiÃ³n
> Â¿CÃ³mo cambian las consideraciones de memoria cuando manejas streams en el navegador?

---

## ğŸ“‚ Ejercicioâ€¯3: Control de concurrencia y UI de rate limiting

### ğŸ¯ Objetivo
Descargar 20 recursos, limitando a **5 descargas simultÃ¡neas**, mostrando un dashboard de estados.

### âœï¸ Instrucciones
1. Simula 20 URLs (p.ej. imÃ¡genes de placeholder).
2. Implementa un gestor de concurrencia en frontend (p.ej. [`p-limit`](https://www.npmjs.com/package/p-limit) adaptado o tu propio pool).
3. Muestra en pantalla un grid o tabla con cada archivo y su estado: pendiente, descargando, Ã©xito, error.
4. AÃ±ade un retraso configurable (p.ej. slider UI) para pausar entre descargas y simular lÃ­mites de API.

### ğŸ” Puntos a cubrir
- Â¿CÃ³mo actualizas la UI sin bloquear el hilo principal?
- Â¿CÃ³mo manejas HTTPâ€¯429 y reintentos automÃ¡ticos?

### â“ ReflexiÃ³n
> Â¿En quÃ© escenarios de frontend real esto te serÃ­a Ãºtil? (p.ej. descargar lotes de assets en PWA)

---

## ğŸš€ Ejercicioâ€¯4 (final): SPA completa con configuraciÃ³n y reporting

### ğŸ¯ Objetivo
Crear una **Single Page App** que unifique configuraciÃ³n, descargas por streams, concurrencia y reporte visual.

### âœï¸ Instrucciones
1. Carga un `config.json` desde tu servidor con:
    - Lista de URLs.
    - Concurrencia mÃ¡xima.
    - Retrasos y reintentos.
2. Por cada URL:
    - Descarga usando streams y muestra barra de progreso.
    - Maneja reintentos en caso de fallo (hasta 2 veces).
3. Al terminar todas, muestra un **dashboard** con:
    - GrÃ¡ficos de tiempos (usando Chart.js o Recharts).
    - Tabla de detalles (URL, estado, tiempo, intentos).
4. Permite exportar el reporte como CSV o JSON desde la UI.

### ğŸ” Puntos a cubrir
- Arquitectura modular: servicios de descarga, componentes de UI, utilidades de reporting.
- Uso de Web Workers si la UI se torna lenta.

### â“ ReflexiÃ³n
> Â¿CÃ³mo mejorarÃ­as la UX si el usuario abandona la pÃ¡gina a mitad de descargas?  
> Â¿PodrÃ­as soportar resuming de descargas parciales?

---

Con estos cambios, la etapa 1 estÃ¡ totalmente orientada al **frontend**, complementando la gestiÃ³n de descargas con una experiencia de usuario sÃ³lida y tÃ©cnicas avanzadas de asincronÃ­a en el navegador.

